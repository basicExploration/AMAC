# 内存模型
go官方介绍go内存模型的时候说：探究在什么条件下，goroutine 在读取一个变量的值的时，能够看到其它 goroutine 对这个变量进行的写的结果。实际上，我们在内存模型中主要探究的有两方面：

- **happens- before**：x 操作一定在 y 操作之前执行完毕，这里说的并不是时间，而是“执行完毕”这个结论，我们可以放心的在y中使用x的执行结果。主要突出的是这个完成性。
- **探究可见性**

我们讨论go内存模型的时候，主要聚焦下面四种细节的差异性：

- 操作的种类：
  - 普通的读或者写
  - 同步操作，比如利用sync包进行同步，利用channel在不同的goroutine中间进行同步，利用atomic包进行同步等。
- 这个操作者在程序中的位置
- 被操作者在内存位置，或者是被访问的变量的位置
- 被操作者值的类型

介绍一些基本的操作：
> 除了基本的读和写之外都是同步操作，包括以下列举的，并且更多以这些基础操作衍生出的操作。 

- 读
  - 基础的读
  - 原子包的读
  - 使用sync.mux 的读
  - 使用channel的收这种形式的读
- 写
  - 基础的写
  - 原子包的写
  - sync.mux 的写
  - 使用channel的发
- atomic的 compare and swap 操作，兼顾了写和读

这里有三条定律：
- 在一个goroutine中，程序执行的顺序一定是符合代码写的顺序的。但是不同的goroutine中这个定理失效。

- 在**同步操作**的时候，从a goroutine看到b goroutine的执行顺序，必须符合同步操作的顺序，这里举个例子，举例：b的同步操作是什么顺序，那么a读取的就是什么顺序。比如 b中有三个Channel，他们执行的顺序是 先 a 发 b 收，b 发，c 收，那么在a中读取的顺序跟这个同步的操作顺序是一致的，如果不是同步操作就可能不一致，比如b这个goroutine中有这样的编码：
  ```go
  fmt.Println("number1")
  fmt.Println("number2")
  
  ```
  在b中他们的执行顺序肯定是 number1 number2 但是如果在a中调用了b，然后我们a等b的结果时，那么发生的顺序就不一定是number1 在number2 前面了，原因就是程序在编译的时候可能是进行重排这种操作。

- 对于非同步操作的普通读和写，如果b操作了a，那么必须成立
  - b发生在a之前

我们可以使用 `go build -race` 来发现数据竞争。


## 重排和可见性

## happens-before



## 参考资料
- https://go.dev/ref/mem

